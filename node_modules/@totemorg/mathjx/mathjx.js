// UNCLASSIFIED

/**
Extends [MathJS]{@link https://mathjs.org/} with program control-blocks.
This module documented in accordance with [jsdoc]{@link https://jsdoc.app/}.

@module MATHJX
@author [ACMESDS](https://totemorg.github.io)

@requires [mathjs](https://www.npmjs.com/package/mathjs)
@requires [enums](https://www.npmjs.com/package/@totemorg/enums)
@requires [cp](https://nodejs.org/docs/latest/api/)
**/

const
	Trace = (msg, ...args) => `jx>>>${msg}`.trace( args );

const 
	{ create, all } = require("mathjs"),
	{ Copy,Start,typeOf } = require("@totemorg/enums");

const 
	{ imports } = $ = module.exports = Copy({
		/**
		Configure MathJX with supplied options hash.
		
		@param {Object} opts Options hash with keys following the deep-copy conventions
		*/
		config: opts => {
			Copy( opts || {} , $, "." );
			$.import(imports, {
				override: true
			});		// import them for access from $(" name(...) ")
			return $;
		},
		/**
		Hash of functions to import into MathJX.
		*/
		imports: {
			// program control

			for: ($ctx, n) => {
				console.log(">>>>>for", $ctx,n);
				return 0;
			},

			while: ($ctx,n) => {
			},

			if: ($ctx,n) => {
			},

			try: ($ctx,n) => {
			},

			switch: ($ctx,n) => {
			},

			when: ($ctx,n) => {
			},

			until: ($ctx,n) => {
			}
		}
	}, Copy( create(all), (code,ctx,cb) => {

		/**
		Reduce program control-blocks to mathjs executable code.  The default language model 
		reduces the following programs:

			if TEST
				DO
			elseif TEST
				DO
			:
			else
				DO
			end

			switch TEST
				case TEST
					DO
				:
				default TEST
					DO
			end

			try
				DO
			catch
				DO
			end

			for INDEX
				DO
			end

			while TEST
				DO
			end

			until TEST
				DO
			end

			when EVENT
				DO
			end

			def f=(x,y,...)
				DO
			end

		Inline functions are also supported using fat-arrows:

			(x,y,...) => {
				DO
			}

		@param {String|Array} pgm Program being parsed.  Use Array to bypass default eol-tokenization.
		@param {Array} blks Stash fo code blocks; initially [].
		@param {Number} idx Current line index to start parsing; initially 0. 
		@param {Object} lang Language model; see code herein.

		@example
			[res,pos] = nest(`
		a1="this;is;a;test";
		cos( 1, ;(u,x) => {
			u+v;
		}, ;def f=(x,y)
			f=x+y;
		end
		)
		for i
			i1
			i2
			for j
				j1; j2;
				while u; u1;end
			end
		end
		a2;
		if u
			u1
			u2
		elseif v
			v1
			v2
		else
			x
		end
		a4
		`, blks=[], 0);

		produces `res`:

			'a1=$ctx[0]\n' +
			'cos( 1, \n' +
			'def($ctx,[1]), def($ctx,[2]))\n' +
			'for($ctx,[5])a2\n' +
			'if($ctx,[6,7,8])a4\n'

		and `blks`:

			[
			  'this;is;a;test',
			  { test: '(u,x)', code: 'u+v\n' },
			  { test: 'f=(x,y)', code: 'f=x+y\n' },
			  { test: 'u', code: ' u1\n' },
			  { test: 'j', code: 'j1\n j2\nwhile($ctx,[3])' },
			  { test: 'i', code: 'i1\ni2\nfor($ctx,[4])' },
			  { test: 'u', code: 'u1\nu2\n' },
			  { test: 'v', code: 'v1\nv2\n' },
			  { test: null, code: 'x\n' }
			]
		**/

		function nest( pgm, blks, idx, lang ) {

			if ( !lang )	// default the language model 
				return nest( pgm, blks||[], idx||0, {
					opens: /^(for|while|if|try|switch|when|until|def) (.*)/,
					terms: /^(end|case|elseif|else|catch|default|\})/,
					close: {
						case: "switch", elseif: "if", else: "if", catch: "try", default: "switch"
					},
					quote: /"(.*)"/g,
					indef: /(.*) => \{$/,
					eol: "\\",
					newl: "\n"
				});

			const
				{opens,terms,indef,close,quote,eol,newl} = lang;

			var
				 code = "";

			if ( !pgm.forEach )		// clean and split the program into lines
				 pgm = pgm
						.replace( /\t/g, "")
						.replace( /\n/g, eol)
						.replace( quote, (x,str) => {
							blks.push( str );
							return `$ctx[${blks.length-1}]`;
						})
						.split(eol);

			for ( var line = pgm[idx]; line !== undefined ; idx++, line=pgm[idx] ) {	// enumerate thru each program line
				if ( ctrl = line.match( indef ) ) {			// start inline def
					var
						[x,arg] = ctrl,
						args = [blks.length],
						op = "def",
						[xcode,xidx] = nest(pgm, blks, idx+1),
						line = pgm[xidx].substr(1);

					//console.log("indef", [arg,xcode,line]);

					blks.push({ test: arg || null, code: xcode });
					code += `${op}($ctx,[${args.join()}])${line}`;
					idx = xidx;
				}

				else
				if ( ctrl = line.match( opens ) ) {			// start an open block
					var
						[x,op,arg] = ctrl,
						args = [];

					//console.log( "open", line, ctrl, [op,arg] );

					do {									// process all valid terminators
						var
							[xcode,xidx] = nest( pgm, blks, idx+1 ),
							line = pgm[xidx] || "",
							[term,xarg] = line.split(" ");

						//console.log( "term=", xcode, "idx=", xidx, "pgm=", pgm);

						args.push( blks.length );
						blks.push({ test: arg || null, code: xcode });

						idx = xidx;
						arg = xarg;

						//console.log("arg", [op, term]);
					}

					while (close[term] == op);

					if (term == "end") {			// terminator closes
						//console.log("end", [op,args,idx]);
						code += `${op}($ctx,[${args.join()}])`;
					}

					else 							// terminator does not properly close
						return [ `invalid terminator "${term}"` , -1 ];
				}

				else
				if ( ctrl = line.match( terms ) ) 			// line terminates a block
					return [code, idx];

				else
				if ( line )									// ignore empty line
					code += line + newl;	
			}

			return [ code, idx ];
		}

		//console.log(">>>>>>>>>", code);
		
		switch ( typeOf(code) ) {
			case "String":	// run a mathjs script 

				if (cb) {
					var vmctx = ctx ? Copy(ctx, {}) : {};

					//console.log("$>>>>>>>>>", $);
					try {
						/*
						for ( var key in vmctx ) 
							if ( val = vmctx[key] ) 
								try {
									Trace(">>vmcb", key, val||false);
									vmctx[key] = isArray(val) ? $.matrix(val) : val;
								}
								catch (err) {
								}
								*/

						$.evaluate(code, vmctx);

						/*
						for ( var key in vmctx ) 
							if ( val = vmctx[key] ) 
								vmctx[key] = val._data || val;
						*/

						cb(vmctx);
						return vmctx;
					}

					catch (err) {
						Trace("error", err, code);
						cb( null );
					}

					//return cb(vmctx) || null;
				}

				else 
				if ( vmctx = ctx ) { // || {}; //Copy(ctx,{}); //new Object(ctx); //{}; // ctx || {};
					try {
						//Trace("code", code, vmctx);
						/*
						for ( var key in vmctx ) {	// list --> matrix
							if ( val = vmctx[key] ) 
								try {
									Trace(">>vm", key, val||false);
									vmctx[key] = isArray(val) ? $.matrix(val) : val;
								}
								catch (err) {
								}
						}
						*/
						vmctx.$ctx = [];

						[code] = nest(code, vmctx.$ctx, 0);

						$.evaluate( code, vmctx);
						//Trace("vm", code, vmctx);

						/*
						for ( var key in vmctx ) // matrix --> list
							if ( val = vmctx[key] ) {
								vmctx[key] = val._data || val;
							}
						*/

						return vmctx;
					}

					catch (err) {
						Trace("error", err, code);
						return null;
					}
				}

				else {
					try {
						return $.evaluate(code);
					}

					catch (err) {
						Trace("error", err, code);
						return null;
					}
				}

				break;

			case "Number":	// create a list
				var 
					rows = code,
					A = new Array(rows);

				return ctx ? A.$(ctx) : A;

			case "Array":		// create a matrix
				var 
					[rows,cols] = code,
					A = new Array(rows);

				for (var m=0; m<rows; m++) A[m] = new Array(cols);

				/*
				var
					dims = code,
					M = dims[0] || 0,
					N = dims[1] || 0,
					cb = ctx,
					A = new Array(M);

				A.rows = M;
				A.columns = N;
				for (var m=0; m<M; m++) A[m] = new Array(N);
				*/

				for (var m=0; m<rows; m++) for (var n=0; n<cols; n++) A[m][n] = 0;

				return ctx ? A.$$(ctx) : A;

			/*
			case "Object":	// import mathjs functions 
				//for (var key in code) Trace(`IMPORTING ${key}`);

				Copy(code, $);		// mix them into $ for access from $[name]

				$.import(code, {
					override: true
				});		// import them for access from $(" name(...) ")

				break;
				*/
		}
	}));

Object.keys($).forEach( key => {
	const
		f = $[key],
		Key = key.charAt(0).toUpperCase()+key.substr(1);
	
	if ( typeof f == "function" )
		if ( sigs = f.signatures )
			if ( sigs.number )
				imports[Key] = x => $.map(x, f);
			
});
	
$.import(imports, {
	override: true
});

Start("mathjx", Copy({
	help: {
		"firefox localhost:8080/${name}.view": imports,
		"firefox https://mathjs.org/docs/reference/functions/${name}.html": $
	}
}, (cmd,ctx) => $(cmd,ctx) ));

// UNCLASSIFIED
